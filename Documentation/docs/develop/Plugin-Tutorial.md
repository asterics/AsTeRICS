# Plugin Tutorial

## Step-by-Step implementation: Averager processor
    

In the following, the implementation on a simpe “averager” component is described. This component realizes some simple processing functionality: It collects its most recent input from one input port and produces its average at one output port. The number of samples to be stored and used for the computation of the average is controlled by a property.

The component shall have a single input port (named “in\_1”), a single output port (named “out\_1), and a single property (named “buffer-size”) which has the type “integer” and the default value “50”.

Using the PluginCreationWizard, the bundle descriptor, the Manifest file, the build script and the skeleton for the JAVA-code can be generated (see section3.1).

Then the actual Java-Code which implements the plugin’s functionality can be added.

The functionality of this component is quite simple: It takes as input integer values, which are queued in a buffer in a first in, first out order (FIFO). Whenever a new value is added, the average of the buffer value is computed and provided in the output. The size of the buffer is controlled by the “buffer-size” property. A possible implementation is shown below.

  
```java
public static final int DEFAULT_BUFFER_SIZE = 10;
    private final LinkedList<Integer> buffer = new LinkedList<Integer>();
    private int bufferSize = DEFAULT_BUFFER_SIZE;


    public Object setRuntimePropertyValue(String propertyName, Object newValue)
    {
        if("buffer-size".equalsIgnoreCase(propertyName))
        {
            final Object oldValue = bufferSize;

            if(newValue != null)
            {
                if(newValue instanceof Integer)
                {
                    bufferSize = (Integer) newValue;
                    // truncate unnecessary tail elements
                    while(bufferSize < buffer.size())
                    {
                        buffer.removeLast();
                    }
                }
                else
                {
                    AstericsErrorHandling.instance.reportError(this,
                     "Invalid property value for "+propertyName+":"+newValue);
                }
            }
            return oldValue;
        }
        return null;
    }



 
   private int addInt(final int in)
    {
        buffer.addFirst(in);
        if(buffer.size() > bufferSize) buffer.removeLast();

        float sum = 0f;
        for(int item : buffer) sum += item;

        return Math.round(sum / buffer.size());
    }

    private class InputPort1 implements IRuntimeInputPort
    {
        public void receiveData(byte[] data)
        {
            int in = ConversionUtils.byteArrayToInt(data);
            outputPort1.sendData(ConversionUtils.intToByteArray(addInt(in)));
        }
    }

    private class OutputPort1 extends DefaultRuntimeOutputPort
    {
        @Override
        public void sendData(byte[] data)
        {
            super.sendData(data);
        }
    }
}
```
  
  
::: tip
The implementation details above build upon the code which is generated by the AsTeRICS PluginCreationWizard tool. Specifically, the above methods belong to the class of the desired “Averager” plugin, which extends and implements the abstract class “AbstractRuntimeComponentInstance”. This class provides some standard implementation of the lifecycle support methods.
:::

The implementations of the input and output ports implement or override that of the “IRuntimeInputPort” and “DefaultRuntimeOutputPort” respectively. In the first case, the “receiveData” method is overridden so that the input bytes are converted to an integer, then processed using the local, private method “addInt”, and finally delegated to the output port. The latter has actually no implementation. A dummy implementation is used to illustrated overriding the “sendData” method, although this could be avoided altogether.

The private method “addInt” realized the core functionality of the averager component. Finally, the get/set property value methods are implemented to allow for getting/setting the value of the “buffer-size” property, in a straightforward manner.
